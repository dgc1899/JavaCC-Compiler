/* adder.jj Para tokenizer*/

options{	
			STATIC=false;
		}
// Bloque de instrucciones para definir el Parser		
PARSER_BEGIN(adder)
import java.util.ArrayList;

class adder{
			public static void main(String[]args)
			throws ParseException, TokenMgrError{
			adder parser=new adder(System.in);
			parser.Programa();}
		}			
PARSER_END(adder)

//Inicio de estados léxicos

SKIP:{" " | "\n" | "\r" | "\r\n" | "\t"}

//Token para Alcance de Identificador
TOKEN:{
<IDREACH:"public "|"private "|"protected " > {System.out.println("IDREACH->"+image+"\r\n");}	
}
//Tokens para declarar metodos y clases
TOKEN:{
	<CLASSTYPE:"abstract | static | const | implements | clascy ">{System.out.println("CLASSTYPE-> "+image+"\r\n");}
}

//Token para tipo de retorno
TOKEN:{
	<VOID:"void ">{System.out.println("VOID-> "+"\r\n");}
}

//Tokens de tipos de numeros
TOKEN:{
		<NUMTYPES:("int "|"byte "|"short "|"long "|"sbyte "|"ushort "|"ulong ")>{System.out.println("NUMTYPES-> "+image+"\r\n");}
		|<FLOATTYPE:("float "|"double "|"decimal ")>{System.out.println("FLOATTYPE-> "+image+"\r\n");}
	}

//Tokens de tipo de datos alfanumericos
TOKEN:{
	<STRINGTYPE:("string ")>{System.out.println("STRINGTYPE-> "+"\r\n");}
	|<CHARTYPE:("char ")>{System.out.println("CHARTYPE-> "+"\r\n");}
}
	
//Token para tipo de dato booleano
TOKEN:{  
   <BOOL:"bool " >{System.out.println("BOOL->"+"\r\n");}
}


//Tokens de símbolos
TOKEN:
{
	<LPAR:"( ">{System.out.println("LPAR->"+"\r\n");}
	| <RPAR:") ">{System.out.println("RPAR->"+"\r\n");}
	| <LBRACE:"{ ">{System.out.println("LBRACE->"+"\r\n");}
	| <RBRACE:"} ">{System.out.println("RBRACE->"+"\r\n");}
	| <SEMICOLON:"; ">{System.out.println("SEMICOL->"+"\r\n");}
	| <COLON:": ">{System.out.println("COL->"+"\r\n");}
	| <COMA:", "> {System.out.println("COMA->"+"\r\n");}
}

//Tokens para bloques repetitivos, control de flujo
TOKEN:{
	<LOOPFOR:"for ">{System.out.println("LOOPFOR-> "+"\r\n");}
}

TOKEN:{
	<LOOPDO:"do "> {System.out.println("LOOPDO-> "+"\r\n");}
}

TOKEN:{
	<LOOPWHILE:"while "> {System.out.println("LOOPWHILE-> "+"\r\n");}
}

//Tokens para operadores aritmeticos
TOKEN:{
	<ARITM:"+ | - | * | / ">{System.out.println("ARITM-> "+image+"\r\n");}
}

//Token para asignar
TOKEN:{
	<ASIGN:"= "> {System.out.println("ASIGN-> "+"\r\n");}
}

//Token para valores de condición
TOKEN:{
	<CONDITION:"true | false "> {System.out.println("CONDITION-> "+image+"\r\n");}
}

//Tokens de operadores relacionales
TOKEN:{
	<RELAT:"== "|"> "|"< "|">= "|"<= "|"<> " >{System.out.println("RELAT-> "+image+"\r\n");}
	|<LOGIC: "&& "|"bitand " |"|| " |"bitor "> {System.out.println("LOGIC-> "+image+"\r\n");}
}

//10 nuevos componentes lexicos Marco
//Tokens de tipo de valor
TOKEN:{
   <STRUCTTYPE:"struct " | "yool " >{System.out.println("STRUCTTYPE-> "+ image+"\r\n");}
}
//Tokens para declarar clase
TOKEN:{
	<CLASS:"class " >{System.out.println("CLASS->\r\n");}

}
//tokens  de etiquetas 
TOKEN:{
	<ALT:"case "| "ing "|"else "|"finally " >{System.out.println("ALT-> "+image+"\r\n");}

}
//tokens estructura repetitivas
TOKEN:{
    <FOREACH:"foreach "|"ingfer " >{System.out.println("FOREACH-> "+image+"\r\n");}
}
//tokens de clausula
TOKEN:{
    <CATCH:"catch "|"except "|"raise " >{System.out.println("CATCH-> "+image +"\r\n");}
}


//Token de bloque try catch
TOKEN:{
	<TRYBLOCK:"try ">{System.out.println("TRYBLOCK->\r\n");}
}

//Token de imprimir a consola
TOKEN:{
	<PRINTOUT:"print | println | writeline"> {System.out.println("PRINTOUT-> "+image+"\r\n");}
}

//Token para delclaraciones de seleccion
TOKEN:{
	<IFSTRUCT: "if "> {System.out.println("IFSTRUCT-> "+"\r\n");}
	|<SWITCHSTRUCT:"switch | stoom "> {System.out.println("SWITCHSTRUCT-> "+image+"\r\n");}
	|<THEN:"then "> {System.out.println("THEN-> "+"\r\n");}
}

//Token para identificadores de usuario
TOKEN:{
	 <NUMBER : (["0"-"9"])+ > {System.out.print("NUM-> "+image+"\r\n");}
	|<LETTER:["A"-"Z","a"-"z"]> {System.out.print("LETTER-> "+image+"\r\n");}
	|<UNDERSC:"_"> {System.out.print("UNDERSC-> "+image+"\r\n");}
	|<WORD:(<LETTER>)+> {System.out.print("WORD-> "+image+"\r\n");}
	|<IDENTIFIER: <LETTER> (<WORD> <NUMBER> <UNDERSC>)*>{System.out.println("IDENTIFIER ->"+image+"\r\n");}
	|<STRING : <LETTER> <NUMBER> (<WORD> <NUMBER>)*>{System.out.print("STRING -> "+image+"\r\n");}
	//|<IDENTIFIER:(["a"-"z","A"-"Z"]) (["a"-"z","A"-"Z","0"-"9","_"])*>{System.out.println("IDENTIFIER ->"+image+"\r\n");}
	//|<STRING : ["a"-"z","A"-"Z","0"-"9"](["a"-"z","A"-"Z","0"-"9"])*>{System.out.print("STRING -> "+image+"\r\n");}
	}
	
//Token para importar paquetes
TOKEN:{
	  <PACKEXP: "packexp"> {System.out.println("PACKEXP-> "+"\r\n");}
	| <IMPORT: "import"> {System.out.println("IMPORT-> "+"\r\n");}
	}
	
//Token para heredar clases
TOKEN:{
	<HCLASS:">> "> {System.out.println("HCLASS-> "+"\r\n");}
}

//Token para palabra reservada def
TOKEN:{
	<DEF: "def "> {System.out.println("DEF-> "+"\r\n");}
}

//Token para palabra clave de metodos
TOKEN:{
	<CONST:"const "> {System.out.println("CONST-> "+"\r\n");}
}

//Token para Return
TOKEN:{
	<RETURN:"return "> {System.out.println("RETURN-> "+"\r\n");}
}

//Token para bloque enum
TOKEN:{
	<ENUM:"enum "> {System.out.println("ENUM-> "+"\r\n");}
}

//Token para estructuras de datos
TOKEN:{
	<LIST:"list "> {System.out.println("list-> "+"\r\n");}
	|<STACK:"stack "> {System.out.println("stack-> "+"\r\n");}
	|<QUEUE:"queue "> {System.out.println("queue-> "+"\r\n");}
}

//Tokens para arreglos
TOKEN:{
	<ARRAY:"array "> {System.out.println("ARRAY-> "+"\r\n");}
	|<STRUCT:"struct "> {System.out.println("STRUCT-> "+"\r\n");}
}
//Fin de estados léxicos

//Inicio de procedimientos para definir patrones


void Start():
{
	int contador = 0;
	Token t;
	ArrayList<String> Lista = new ArrayList<String>();
}
{

	(

		
	<NUMBER>
	|<STRING>
	|<IDREACH>
	|<CLASSTYPE>
	|<VOID>
	|<NUMTYPES>
	|<FLOATTYPE>
	|<STRINGTYPE>
	|<CHARTYPE>
	|<BOOL>
	|<LPAR>
	|<RPAR>
	|<LBRACE>
	|<RBRACE>
	|<SEMICOLON>
	|<ARITM>
	|<CONDITION>
	|<RELAT>
	|<STRUCTTYPE>
	|<CLASS>
	|<ALT>
	|<FOREACH>
	|<CATCH>
	|<TRYBLOCK>
	|<PRINTOUT>
	|<IFSTRUCT>
	|<SWITCHSTRUCT>
	|
		 t = <IDENTIFIER>
		{String variable = t.image;}
			{
				if(Lista.contains(variable))
				{
					
				}
				else
				{
					Lista.add(variable);
				}
				contador++;
			}

		{System.out.println("Identificador: " + variable + " " + Lista.indexOf(variable) );} 
	)*	
}

void Programa():
{}
{
	<IDENTIFIER> (Librerias())? (Clase())* <COLON>
}

void Librerias():
{}
{
	(<PACKEXP> <IDENTIFIER>)+
}

void Clase():
{}
{
	(Heredar())? <CLASS> <IDENTIFIER> (DeclarVarGlob() | Metodo())* <COLON>
}


void Heredar():
{}
{
	<IDENTIFIER> <HCLASS>
}

void DeclarVarGlob():
{}
{
	<DEF> DefinirVariables() <COLON>
}

void DefinirVariables():
{}
{
	(<IDENTIFIER> <ASIGN> (<NUMTYPES>|<FLOATTYPE>|<BOOL>|<STRINGTYPE>|<CHARTYPE>) )+
}

void Metodo():
{}
{
	<CONST><VOID><IDENTIFIER> Bloque() Return() <COLON>
}

void Bloque():
{}
{
	Instrucciones()
}

void Instrucciones():
{}
{
	(Ciclos() Pregunta() ImpCons() declarVarLocal() OpAritmetica())*
}

void ImpCons():
{}
{
      <PRINTOUT> (Valor() | <IDENTIFIER>)
 }
 


void Return():
{}
{
	<RETURN> <IDENTIFIER>
}

void declarVarLocal():
{}
{
	<DEF> DefinirVariables() <COLON>
}

void Ciclos():
{}
{
	CicloFor()  CicloWhile()  CicloDo()
}

void CicloFor():
{}
{
	<LOOPFOR> EstructuraFor() Bloque()
}

void EstructuraFor():
{}
{
	Condicion() <COMA> <IDENTIFIER> <ASIGN> Valor() <COMA> Incremento()
}

void Incremento():
{}
{
	<IDENTIFIER> <ARITM> Valor()
}

void CicloWhile():
{}
{
	<LOOPWHILE> Condicion() Bloque()
}

void CicloDo():
{}
{
       <LOOPDO> Bloque() <LOOPWHILE> Condicion()
}

void Pregunta():
{}
{
      <IFSTRUCT> Condicion() <THEN> Bloque() (Sino())?
}


void Sino():
{}
{
     <ALT> Bloque()
}

void Condicion():
{}
{
     Oprelacional() (<LOGIC> Oprelacional())*
}

void OpAritmetica():
{}
{
     <IDENTIFIER>  (<ASIGN>)? Valor() (<ARITM> (Valor()))*
}

void Oprelacional():
{}
{
    (OpAritmetica() Valor()) <RELAT> (OpAritmetica()  Valor())
}


void Valor():
{}
{
    (<CONDITION> | <NUMBER> | <STRING>)
}

void Enumerable():
{}
{
     <CONST> <ENUM> BloqueEnum() <COLON>
}

void BloqueEnum():
{}
{
     (Valor())+
}


void Estructura():
{}
{
    (<STRING>|<NUMBER>) (EstructuraDatos() | EstructuraEstatica()) <IDENTIFIER>
}

void EstructuraDatos():
{}
{
    <LIST> | <STACK> | <QUEUE>
}

void EstructuraEstatica():
{}
{
   <ARRAY> | <STRUCT>
}
